// frontend/app/games/stock-101/page.tsx
"use client";

import React, { useState, useEffect, useCallback } from 'react';
import StockSelectorPanel from '../../../components/StockSelectorPanel';
import MainChartDisplay from '../../../components/MainChartDisplay';
import PortfolioDisplay from '../../../components/PortfolioDisplay';
import BuyPanel from '../../../components/BuyPanel';
import SellPanel from '../../../components/SellPanel';
import { v4 as uuidv4 } from 'uuid'; // Ensure installed: npm install uuid @types/uuid
import styles from './Stock101Page.module.css'; // Import page-specific CSS module

// --- Interfaces ---
interface StockData {
    [ticker: string]: number[];
}

interface Position {
    id: string; // Unique ID for each position lot
    ticker: string;
    entryPrice: number;
    quantity: number;
    leverage: number;
    entryStep: number;
}

// Interface for Trade History (for chart markers/tooltips)
interface Trade {
    id: string;
    step: number; // Step number (0-based index) when trade occurred
    ticker: string;
    action: 'BUY' | 'SELL';
    quantity: number;
    price: number;
    leverage: number;
    realizedPnl?: number; // Optional: only for SELL trades
}

// --- Component ---
const BACKEND_URL = 'http://127.0.0.1:8000'; // Your backend URL
const GAME_DURATION_SECONDS = 600; // 10 minutes
const DATA_POINTS_EXPECTED = 100; // Number of data points generated by backend
const UPDATE_INTERVAL_MS = (GAME_DURATION_SECONDS / DATA_POINTS_EXPECTED) * 1000; // ~6 seconds
// const UPDATE_INTERVAL_MS = 1000; // Faster for testing
const initialCash = 100000; // Starting cash

export default function Stock101Page() {
    // --- State ---
    const [gameData, setGameData] = useState<StockData | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [gameStarted, setGameStarted] = useState<boolean>(false);
    const [currentStep, setCurrentStep] = useState<number>(0);
    const [isGameOver, setIsGameOver] = useState<boolean>(false);
    const [selectedTicker, setSelectedTicker] = useState<string>('');
    const [cash, setCash] = useState<number>(initialCash);
    const [positions, setPositions] = useState<Position[]>([]);
    const [portfolioValue, setPortfolioValue] = useState<number>(initialCash); // Represents Equity
    const [leverage, setLeverage] = useState<number>(1); // Leverage selection for NEXT trade
    const [tradeMessage, setTradeMessage] = useState<{ type: 'error' | 'success' | 'info', text: string } | null>(null);
    const [liquidatedMessage, setLiquidatedMessage] = useState<string | null>(null);
    const [tradeHistory, setTradeHistory] = useState<Trade[]>([]); // State for trade history

    // --- Helper Functions ---
    const getCurrentPrice = useCallback((ticker: string): number | null => {
        if (!gameData || !gameData[ticker] || gameData[ticker].length <= currentStep) {
            return null;
        }
        const price = gameData[ticker][currentStep];
        return (typeof price === 'number' && price >= 0 && !isNaN(price)) ? price : null;
    }, [gameData, currentStep]);

    // --- Game Control ---
    const startGame = useCallback(async () => {
        setIsLoading(true); setError(null); setGameData(null); setGameStarted(false);
        setCurrentStep(0); setIsGameOver(false); setSelectedTicker(''); setCash(initialCash);
        setPositions([]); setPortfolioValue(initialCash); setLeverage(1);
        setTradeMessage(null); setLiquidatedMessage(null); setTradeHistory([]); // Reset trade history

        try {
            const response = await fetch(`${BACKEND_URL}/game_simulation_data`);
            if (!response.ok) { const errTxt = await response.text(); throw new Error(`API Error: ${response.status} - ${errTxt}`); }
            const data: { status: string; stock_data?: StockData; detail?: string } = await response.json();
            if (data.status === 'success' && data.stock_data) {
                const tickers = Object.keys(data.stock_data);
                if (tickers.length === 0 || Object.values(data.stock_data).some(arr => !Array.isArray(arr) || arr.length !== DATA_POINTS_EXPECTED)) { throw new Error(`Invalid data received.`); }
                setGameData(data.stock_data);
                const firstTicker = tickers[0];
                if (firstTicker) { setSelectedTicker(firstTicker); }
                setGameStarted(true);
            } else { throw new Error(data.detail || 'Backend error.'); }
        } catch (err) { if (err instanceof Error) { setError(err.message); } else { setError("Unknown fetch error."); } console.error("Fetch error:", err); setGameStarted(false); }
        finally { setIsLoading(false); }
    }, []);

    // --- UI Callbacks ---
    const handleSelectTicker = (ticker: string) => { setSelectedTicker(ticker); };
    const handleSetLeverage = (newLeverage: number) => { setLeverage(newLeverage); };

    // --- Trade Execution ---
    const handleBuy = useCallback((ticker: string, quantity: number, tradeLeverage: number) => {
        setTradeMessage(null); setLiquidatedMessage(null);
        if (isGameOver || !gameData || quantity <= 0 || !Number.isInteger(quantity)) { setTradeMessage({ type: 'error', text: quantity <= 0 ? "Quantity must be positive integer." : "Game not active." }); return; }
        const currentPrice = getCurrentPrice(ticker);
        if (currentPrice === null || currentPrice <= 0) { setTradeMessage({ type: 'error', text: "Invalid current price for buy." }); return; }

        const cost = quantity * currentPrice;
        const marginRequired = cost / tradeLeverage;

        if (cash >= marginRequired) {
            const newPosition: Position = { id: uuidv4(), ticker: ticker, entryPrice: currentPrice, quantity: quantity, leverage: tradeLeverage, entryStep: currentStep };
            const newTrade: Trade = { id: uuidv4(), step: currentStep, ticker: ticker, action: 'BUY', quantity: quantity, price: currentPrice, leverage: tradeLeverage };
            setTradeHistory(prev => [...prev, newTrade]);
            setCash(prevCash => prevCash - marginRequired);
            setPositions(prevPositions => [...prevPositions, newPosition]);
            setTradeMessage({ type: 'success', text: `Bought ${quantity} ${ticker} @ ${currentPrice.toFixed(2)} (Lev: ${tradeLeverage}x, Margin: $${marginRequired.toFixed(2)})` });
        } else {
            setTradeMessage({ type: 'error', text: `Insufficient cash. Need margin $${marginRequired.toFixed(2)}, have $${cash.toFixed(2)}` });
        }
    }, [cash, currentStep, gameData, isGameOver, getCurrentPrice]);

    const handleSell = useCallback((ticker: string, quantityToSell: number, isLiquidation: boolean = false) => {
        if (!isLiquidation) { setTradeMessage(null); setLiquidatedMessage(null); }
        if ((isGameOver && !isLiquidation) || !gameData || quantityToSell <= 0) { if (!isLiquidation) setTradeMessage({ type: 'error', text: "Game not active or invalid quantity." }); return false; }
        const currentPrice = getCurrentPrice(ticker);
        const effectiveSellPrice = currentPrice ?? 0;
        if ((effectiveSellPrice < 0 || currentPrice === null) && !isLiquidation) { if (!isLiquidation) setTradeMessage({ type: 'error', text: "Invalid price for sell." }); return false; }

        let remainingToSell = quantityToSell;
        let totalRealizedPnl = 0;
        let totalMarginFreed = 0;
        let actualQuantitySold = 0;
        let leverageOfSoldShares = 1;
        const updatedPositions: Position[] = [];
        const positionsForTicker = positions.filter(p => p.ticker === ticker).sort((a, b) => a.entryStep - b.entryStep);
        const otherPositions = positions.filter(p => p.ticker !== ticker);
        const totalSharesHeld = positionsForTicker.reduce((sum, p) => sum + p.quantity, 0);
        const tolerance = 1e-9;

        if (totalSharesHeld < quantityToSell - tolerance) { if (!isLiquidation) setTradeMessage({ type: 'error', text: `Not enough shares. Have ${totalSharesHeld.toFixed(4)}, tried ${quantityToSell}` }); return false; }

        for (const pos of positionsForTicker) {
            if (remainingToSell <= tolerance) { updatedPositions.push(pos); continue; }
            const sellQtyFromThisPos = Math.min(remainingToSell, pos.quantity);
            const costBasisForSold = sellQtyFromThisPos * pos.entryPrice;
            const marginFreed = costBasisForSold / pos.leverage;
            const realizedPnl = (effectiveSellPrice - pos.entryPrice) * sellQtyFromThisPos * pos.leverage;
            totalRealizedPnl += realizedPnl;
            totalMarginFreed += marginFreed;
            remainingToSell -= sellQtyFromThisPos;
            actualQuantitySold += sellQtyFromThisPos;
            leverageOfSoldShares = pos.leverage;
            if (pos.quantity - sellQtyFromThisPos > tolerance) {
                updatedPositions.push({ ...pos, quantity: pos.quantity - sellQtyFromThisPos });
            }
        }

        if (actualQuantitySold > tolerance) {
            setPositions([...otherPositions, ...updatedPositions]);
            setCash(prevCash => prevCash + totalMarginFreed + totalRealizedPnl);
            const newTrade: Trade = { id: uuidv4(), step: currentStep, ticker: ticker, action: 'SELL', quantity: actualQuantitySold, price: effectiveSellPrice, leverage: leverageOfSoldShares, realizedPnl: totalRealizedPnl };
            setTradeHistory(prev => [...prev, newTrade]);
            if (!isLiquidation) { setTradeMessage({ type: 'success', text: `Sold ${actualQuantitySold.toFixed(4)} ${ticker} @ ${effectiveSellPrice.toFixed(2)}. P&L: $${totalRealizedPnl.toFixed(2)}` }); }
            return true;
        } else {
            if (!isLiquidation) setTradeMessage({ type: 'error', text: `Sell quantity too small or error.` });
            return false;
        }
    }, [positions, currentStep, gameData, isGameOver, getCurrentPrice]);

    // --- useEffect Hooks ---
    // Recalculate Equity & Check Liquidations Effect
    useEffect(() => {
        if (!gameStarted || !gameData || !positions) return;
        let calculatedEquity = cash;
        let positionsToKeep: Position[] = [];
        let liquidatedPositionsThisStep: Position[] = [];
        positions.forEach(pos => {
            const currentPrice = getCurrentPrice(pos.ticker);
            let keepPosition = true;
            if (currentPrice === null) {
                calculatedEquity += (pos.entryPrice * pos.quantity) / pos.leverage;
            } else {
                const requiredMargin = (pos.entryPrice * pos.quantity) / pos.leverage;
                const priceRatio = pos.entryPrice > 1e-9 ? (currentPrice / pos.entryPrice) : 0;
                const lossPercentLeveraged = (priceRatio - 1) * pos.leverage;
                const liquidationThreshold = -1.0 + 1e-9;
                if ((lossPercentLeveraged <= liquidationThreshold && pos.leverage > 1) || currentPrice <= 1e-9) {
                    liquidatedPositionsThisStep.push(pos); keepPosition = false;
                    console.warn(`LIQUIDATION Check: ${pos.ticker}`);
                } else {
                    const unrealizedPnl = (currentPrice - pos.entryPrice) * pos.quantity * pos.leverage;
                    calculatedEquity += requiredMargin + unrealizedPnl;
                }
            }
            if (keepPosition) { positionsToKeep.push(pos); }
        });

        setPortfolioValue(calculatedEquity);

        if (liquidatedPositionsThisStep.length > 0) {
            let totalLiquidationPnl = 0;
            let anySellFailed = false;
            liquidatedPositionsThisStep.forEach(pos => {
                const liquidationPrice = getCurrentPrice(pos.ticker) ?? 0;
                const pnl = (liquidationPrice - pos.entryPrice) * pos.quantity * pos.leverage;
                totalLiquidationPnl += pnl;
                const success = handleSell(pos.ticker, pos.quantity, true);
                if (!success) anySellFailed = true;
            });
            setPositions(currentPositions => currentPositions.filter(p => !liquidatedPositionsThisStep.some(lp => lp.id === p.id)));
            setLiquidatedMessage(`${liquidatedPositionsThisStep.length} position(s) liquidated! Realized P&L: $${totalLiquidationPnl.toFixed(2)}`);
            if (anySellFailed) console.error("One or more liquidating sells reported failure.");
        } else {
            setLiquidatedMessage(null);
        }
    }, [currentStep, cash, positions, gameData, gameStarted, getCurrentPrice, handleSell]);

    // Bankruptcy Check Effect
    useEffect(() => {
        if (gameStarted && !isGameOver && portfolioValue <= 0 && positions.length === 0) {
            console.error("BANKRUPT!"); setIsGameOver(true);
            setLiquidatedMessage(null);
            setTradeMessage({ type: 'error', text: `BANKRUPT! Equity reached $${portfolioValue.toFixed(2)}` });
        }
    }, [portfolioValue, positions, gameStarted, isGameOver]);

    // Game Loop Timer Effect
    useEffect(() => {
        if (!gameStarted || !gameData || isGameOver) return;
        const intervalId = setInterval(() => setCurrentStep(prev => prev + 1), UPDATE_INTERVAL_MS);
        if (currentStep >= DATA_POINTS_EXPECTED - 1) {
            clearInterval(intervalId);
            if (!isGameOver) { setIsGameOver(true); console.log("Game ended: Final step."); }
        }
        return () => clearInterval(intervalId);
    }, [gameStarted, gameData, isGameOver, currentStep]);

    // --- Prepare Render Data ---
    const availableTickers = gameData ? Object.keys(gameData) : [];
    const currentSelectedPrice = selectedTicker ? getCurrentPrice(selectedTicker) : null;
    // Filter trade history for the selected ticker to pass to the chart
    const tradesForSelectedTicker = tradeHistory.filter(t => t.ticker === selectedTicker);

    // --- Render ---
    return (
        // Use CSS module class for page container
        <div className={styles.pageContainer}>
            <h1 className={styles.pageTitle}>Stock 101 Trading Simulation</h1>

            {!gameStarted && (<button onClick={startGame} disabled={isLoading} className={styles.startButton}> {isLoading ? 'Loading...' : 'Start Interview Session'} </button>)}
            {isLoading && <p className={styles.loadingMessage}>Loading...</p>}
            {error && <p className={styles.errorMessage}>Error: {error}</p>}

            {gameStarted && gameData && (
                <div className={styles.gameLayout}>

                    {/* --- Main Content Column --- */}
                    <div className={styles.mainContent}>
                        <div className={styles.gameStatus}>
                            <span>Step: {currentStep + 1} / {DATA_POINTS_EXPECTED}</span>
                            {isGameOver && <span className={styles.gameOver}>GAME OVER</span>}
                        </div>
                        {(liquidatedMessage || tradeMessage) && (
                            <div className={`${styles.tradeMessage} ${liquidatedMessage ? styles.error : (tradeMessage?.type === 'error' ? styles.error : styles.success)}`}>
                                {liquidatedMessage || tradeMessage?.text}
                            </div>
                        )}

                        {selectedTicker && gameData[selectedTicker] ? (
                            <MainChartDisplay
                                key={selectedTicker}
                                ticker={selectedTicker}
                                priceHistory={gameData[selectedTicker]}
                                currentStep={currentStep}
                                trades={tradesForSelectedTicker} // Pass trades for markers/tooltips
                            />
                        ) : availableTickers.length > 0 ? (<p>Select a stock.</p>) : null}

                        {selectedTicker && gameData[selectedTicker] && (
                            <div className={styles.tradeControlsContainer}>
                                <BuyPanel
                                    ticker={selectedTicker} currentPrice={currentSelectedPrice}
                                    cash={cash} leverage={leverage} onSetLeverage={handleSetLeverage}
                                    onBuy={handleBuy} // Pass quantity now
                                    disabled={isGameOver}
                                />
                                <SellPanel
                                    ticker={selectedTicker} currentPrice={currentSelectedPrice}
                                    positions={positions} // Pass all positions
                                    onSell={handleSell} // Pass quantity
                                    disabled={isGameOver}
                                />
                            </div>
                        )}
                    </div>

                    {/* --- Sidebar Column --- */}
                    <div className={styles.sidebar}>
                        <StockSelectorPanel
                            tickers={availableTickers}
                            selectedTicker={selectedTicker}
                            onSelectTicker={handleSelectTicker}
                        />
                        <PortfolioDisplay
                            cash={cash}
                            positions={positions}
                            portfolioValue={portfolioValue} // Represents Equity
                            currentLeverageSelection={leverage}
                            gameData={gameData}
                            currentStep={currentStep}
                        />
                    </div>
                </div>
            )}
        </div>
    );
}